Vagrant – консольная утилита, которая управляет виртуальными машинами.
По умолчанию Vagrant работает с системой виртуализации VirtualBox.

Vagrant создает изолированные среды разработки,
при этом не жертвуя привычными инструментами (редакторы, браузеры и т. д.) и оставляя основную систему чистой.

В папке проекта создается файл Vagrantfile с описанием конфигурации виртуальной машины, в котором указывается операционная система,
выделяемые ресурсы, сетевые настройки и скрипты по установке и настройке дополнительных программ.

//Проверка версии
vagrant -v

//Создание Vagrantfile в текущей директории. В нем на языке Ruby описывается конфигурация виртуальной машины
vagrant init

//Запускает виртуальную машину, создавая её, если она ещё не существует. Также выполняет все настройки, указанные в Vagrantfile, включая синхронизацию папок, настройку сети, установку зависимостей и т.д.
vagrant up
vagrant up --debug - Запуск с подробным отображением ошибок

//Останавливает запущенную виртуальную машину. Это аналог нажатия кнопки "Выключить" в VirtualBox. Виртуальная машина остаётся сохранённой на диске и может быть запущена снова.
vagrant halt

//Перезапускает виртуальную машину. Полезно, если вы внесли изменения в Vagrantfile (например, изменили настройки сети или синхронизации) и хотите их применить.
vagrant reload

//Полностью удаляет виртуальную машину вместе со всеми её файлами. После выполнения этой команды машина исчезает из VirtualBox.
vagrant destroy

//Сохраняет текущее состояние виртуальной машины и останавливает её. Это аналог функции "Сохранить состояние" в VirtualBox. Позволяет быстро вернуться к работе без полной перезагрузки.
vagrant suspend

//Возобновляет работу виртуальной машины после выполнения команды vagrant suspend.
vagrant resume

//Подключается к виртуальной машине через SSH. Это позволяет вам работать с машиной из командной строки.
vagrant ssh

//Показывает статус виртуальной машины (например, запущена ли она, остановлена или отсутствует).
vagrant status

//Показывает список всех базовых образов (boxes), которые доступны на вашем компьютере.
vagrant box list

//Cкачать бокс на компьютер
vagrant box add ubuntu/jammy64

//Удаляет базовый образ из локального хранилища.
vagrant box remove <box-name>

//Показывает список всех машин Vagrant, созданных на вашем компьютере (даже если вы находитесь в другой директории).
vagrant global-status

//Команда vagrant provision выполняет провиженинг (настройку) виртуальной машины.
Это процесс выполнения скриптов или инструкций, которые указаны в Vagrantfile для настройки машины после ее создания.
vagrant provision

--пример:
config.vm.provision "shell", inline: <<-SHELL
    sudo apt update
    sudo apt install -y python3-pip python3-virtualenv postgresql nginx
  SHELL


---- Запуск на Linux Сервере без Docker ----
Будем использовать:
gunicorn
nginx

//Переходим в нужный нам каталог
cd opt/myapp

//Обновляем сведения о пакетах
sudo apt update

//Устанавливаем pip venv postgres nginx - они нужны для проекта
-y или --assume-yes   чтобы не запрашивался ввод Y/n
--quiet или -q   уменьшает вывод в терминале.
sudo apt install -y python3-pip python3-virtualenv postgresql nginx

Создаём виртуальное окружение. --always-copy так как используется синхронизация папок
virtualenv venv --always-copy

//активация окружения
. ./venv/bin/activate

//Устанавиваем зависимости
pip install -r requirements.txt

//Войдём в консоль postgres
sudo -u postgres psql

//Проверка версии
select version();

//Создадим базу
create database django_app;
create user django_app with password 'django_app';
grant all privileges on database django_app to django_app;

//Так как postgres 15 версии:
alter database django_app owner to django_app;
\q

Начальная настройка postgres закончена

python3 ./django_project/manage.py migrate
python3 ./django_project/manage.py createsuperuser
admin
admin@example.com
admin
admin


База создана схема применена суперпользователь создан


---- Настройка gunicorn ----
gunicorn используется для взаимодействия между Django и веб-сервером
Обёртка, которая будет запускать Django приложение в несколиких экземплярах

pip install gunicorn

-- Настройки чтобы через gunicorn запустить приложение
Понаобится несколько конфигурационных файлов:
Добавляем папку conf
Назовём файл по имени приложения, которое будет стартовать
gunicorn.socket - специальный файл, который описывает UNIX сокет
сокет будет подниматься системной службой systemD, которая ответственна за запуск и остановку и выполнение сервисов


Описание:
[Unit]
Description=gunicorn socket

Сам сокет - где будет этот сокет располагаться на файловой системе linux
[Socket]
ListenStream=/run/gunicorn.sock

Стандартная служебная зависимост что он будет запускаться сокетом
[Install]
WantedBy=sockets.target

---- Теперь нужно подготовить ещё один файл для работы с gunicorn ----
- конфигурация  которая будет запускать сам gunicorn чтобы он через этот сокет отдавал данные через приложение
Создаём файл gunicorn.service

файл systemd unit для конфигурации сервиса Gunicorn, который запускает WSGI-приложение:
[Unit]
Description=gunicorn daemon: Это описание сервиса, чтобы другие могли понять, что делает данный юнит — он является демоном Gunicorn.
Requires=gunicorn.socket: Означает, что этот сервис зависит от юнита gunicorn.socket. Он не будет запущен, если юнит gunicorn.socket не будет активирован.
After=network.target: Указывает, что юнит должен запускаться только после того, как сеть была настроена (после достижения network.target).

Не используем пользователя root чтобы не допустить проблем с безопасностью

[Service]
User=www-data: Указывает, что сервис будет запущен от имени пользователя www-data. Стандартный при Nginx
Group=www-data: Указывает, что сервис будет запущен в группе www-data.
WorkingDirectory=/opt/myapp/app: Указывает рабочую директорию, в которой будет запущен сервис.
ExecStart=...: Команда, которую systemd выполняет для запуска сервиса. Здесь запускается gunicorn из виртуального окружения, с параметрами:

--access-logfile -: Логирование доступа в стандартный вывод.
--workers 3: Количество воркеров, обслуживающих запросы (в данном случае 3 воркера).
--bind unix:/run/gunicorn.sock: Привязка Gunicorn к UNIX-сокету, расположенному по пути /run/gunicorn.sock.
app.wsgi:application: Указывает путь к WSGI-приложению, которому Gunicorn должен передавать HTTP-запросы.

[Install]
WantedBy=multi-user.target: Указывает, что данный юнит должен запускаться в многопользовательской среде (уровень инициализации с более чем одной пользовательской сессией), обычно это почти вся загрузка системы.
Этот файл, скорее всего, будет находиться в директории /etc/systemd/system/ и позволяет управлять сервисом Gunicorn с помощью systemctl, например, запускать и останавливать его.


Файл с описанием сервиса подготовлен. Нужно сделать так, чтобы они были использованы системой
Можно их скопироватьв  каталог etc где они обычно распологаются
Но мы сделаем симулинк чтобы конфигурационные файлы оставались в рамках каталога с проектом
Если что-то поменяем, сможем применить без дополнительного копирования

Делаем симулинки:
sudo ln -s /opt/myapp/conf/gunicorn.socket /etc/systemd/system/

sudo ln -s /opt/myapp/conf/gunicorn.service /etc/systemd/system/

Чтобы systemd понял что мы ему добавили описаное новой конфигурации сокета и сервиса, необходимо выоплнить команду:
Эта команда сообщает systemd сервису что нужно перезагрузить файлы сервиса которые находятся на диске
//Пока мы этого не сделаем, он пользоваться этими файлами не будет
sudo systemctl daemon-reload


//Запустим наш сокет
sudo systemctl start gunicorn.socket

//И сразу же его включим
//Пока мы его не включим, в случае перезагрузки сервера он не будет заново включен
sudo systemctl enable gunicorn.socket

Результат - Created symlink /etc/systemd/system/sockets.target.wants/gunicorn.socket → /opt/myapp/conf/gunicorn.socket.

//Теперь мы можем проверить статус gunicorn.socket
sudo systemctl status gunicorn.socket

//Можно проверить создался ои файл в файловой системе
file /run/gunicorn.sock

Теперь нужно убедиться что Django приложение через сокет будет доступно
Юникорн сервис должен автоматически запуститься в тот момент, когда мы будем обращаться к юникорн сокету
//Подключимся сразу же к юникс сокету который подняли
curl --unix-socket /run/gunicorn.sock localhost

Recv failure: Connection reset by peer

Изменяем настройки
ALLOWED_HOSTS = ['localhost', 'myapp.django']


//Смотрим лог если не работает
sudo tail -f /var/log/syslog

//Если изменили настройки сокета:
sudo systemctl daemon-reload
sudo systemctl restart gunicorn
sudo systemctl status gunicorn.socket


---- Настройка Nginx ----

Расширение .nginx только для проверки синтаксиса
Добавимм конфигурационный файлик для Nginx
myapp.nginx

Конфигурация nginx состоит из обязательных секций, таких как сервер
Внутри которого описываются параметры на каком порту мы слушаем, указание доменного имени

location определеняет из какого источника брать данные к которым происходит запрос, который nginx обрабатывает
Запросы идут к джанге
К ней мы обращаемся через сокет

Проксируем на юникс порт который расположен по тому пути, на котором мы создавали
proxy_pass http://unix:/

-- Статика

Если бы у нас был простой python скрипт, который просто отвечает API и больше ничего не делает, этого было бы достаточно
Но у нас ещё особенность Django - вне DEBUG нужно обеспечить отдачу пользователям статических файлов
Для этого нужно прописать дополнительно location /static/ и описать там, откуда мы будем брать эту статику
Статику мы будем собирать в каталог рядом с нашим приложением

Также добавляем настройку django_app
STATIC_ROOT = BASE_DIR.parent / 'static'

//Выполняем команду чтобы собрать статику
python3 ./django_project/manage.py collectstatic

Теперь Nginx сможет из него брать файлы, которые нужно бдет отдавать пользователю

Nginx пока не знает что у нас есть эта конфигурация

//Выдаёт какую-то заглушку
cat /etc/nginx/sites-enabled/default
//Этот файл настроек нам не нужен, просто его удалим и подставим свою настройку
sudo rm /etc/nginx/sites-enabled/default

Есть в каталоге настроек Nginx два каталога которые нас интересуют:
Sites available - доступные сайты (которые Nginx мог бы обслуживать)
Sites  Enabled - сайты которые Nginx реально обслуживает. Содержит симулинки на файлы которые лежат вsites available

//Сделаем симулинк к нашим настройкам
sudo ln -s /opt/myapp/conf/myapp.nginx /etc/nginx/sites-available/

//Теперь сделаем из него симулинк в enabled
sudo ln -s /etc/nginx/sites-available/myapp.nginx /etc/nginx/sites-enabled/

//Конфигурацию подложили в каталог настроек Nginx, она должна сработать
cat /etc/nginx/sites-enabled/myapp.nginx
//Проверим что nginx не видит в конфигурации ошибку, и синтаксис корректен
sudo nginx -t


//Теперь нужно перезапустить сервис Nginx для того чтобы он применил эти настройки
//Так как он всё ещё работает с настройкой, которая была до наших манипуляций
sudo systemctl restart nginx

Итого мы создали сокет, создали сервис на unicorn, прописали запуск через него нашего приложения, подготовили базу, подготовили nginx
Можно проверить что в итоге получилось


---- Запуск на Linux Серере через docker-compose ----







